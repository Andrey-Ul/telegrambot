1. Тест Class SendBotMessageServiceTest, public void shouldProperlySendMessage()

При помощи Mockito создаётся моковый объект TelegramBot, который передаётся в конструктор нашему сервису.

Далее написали один тест (каждый метод с аннотацией Test — это отдельный тест).
Структура этого метода одна и та же всегда — он не принимает аргументы, и возвращает void.
Имя теста должно рассказать о том, что мы тестируем. В нашем случае это:

should properly send message — должен правильно отправить сообщение.

Тест у нас поделен на три части:

    блок //given — где мы подготавливаем все необходимое к тесту;
    блок //when — где запускаем тот метод, который планируем тестировать;
    блок //then — где мы проверяем, правильно ли отработал метод.

Так как пока что логика в нашем сервисе простая, одного теста для этого класса будет достаточно.

2. Test CommandContainerTest

Здесь не совсем очевидный тест. Он опирается на логику работы контейнера.
Все команды, которые поддерживает бот, находятся в списке CommandName и должны быть в контейнере.
Поэтому берем все переменные CommandName, переходим в Stream API и для каждого выполняем поиск команды из контейнера.
Если бы такой команды не было, была бы возвращена команда UnknownCommand.

Это мы и проверяем в этой строке:

Assertions.assertNotEquals(UnknownCommand.class, command.getClass());

А чтобы проверить, что по умолчанию будет UnknownCommand, нужен отдельный тест — shouldReturnUnknownCommand.

Для команд пока что будут полуформальные тесты, но их нужно писать.
Логика будет такая же, как и для тестирования SendBotMessageService,
поэтому вынесим общую логику тестов в AbstractCommandTest класс,
и уже каждый конкретный тест-класс будет наследоваться и определять необходимые ему поля.

Отлично видно, что игра стоила свеч, и благодаря AbstractCommandTest мы получили в итоге простые и понятные тесты,
которые легко писать, легко понимать.
В довесок избавились от лишнего дублирования кода (привет принципу DRY -> Don’t Repeat Yourself).