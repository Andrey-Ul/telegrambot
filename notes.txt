1. Тест Class SendBotMessageServiceTest, public void shouldProperlySendMessage()

При помощи Mockito создаётся моковый объект TelegramBot, который передаётся в конструктор нашему сервису.

Далее написали один тест (каждый метод с аннотацией Test — это отдельный тест).
Структура этого метода одна и та же всегда — он не принимает аргументы, и возвращает void.
Имя теста должно рассказать о том, что мы тестируем. В нашем случае это:

should properly send message — должен правильно отправить сообщение.

Тест у нас поделен на три части:

    блок //given — где мы подготавливаем все необходимое к тесту;
    блок //when — где запускаем тот метод, который планируем тестировать;
    блок //then — где мы проверяем, правильно ли отработал метод.

Так как пока что логика в нашем сервисе простая, одного теста для этого класса будет достаточно.

2. Test CommandContainerTest

Здесь не совсем очевидный тест. Он опирается на логику работы контейнера.
Все команды, которые поддерживает бот, находятся в списке CommandName и должны быть в контейнере.
Поэтому берем все переменные CommandName, переходим в Stream API и для каждого выполняем поиск команды из контейнера.
Если бы такой команды не было, была бы возвращена команда UnknownCommand.

Это мы и проверяем в этой строке:

Assertions.assertNotEquals(UnknownCommand.class, command.getClass());

А чтобы проверить, что по умолчанию будет UnknownCommand, нужен отдельный тест — shouldReturnUnknownCommand.

Для команд пока что будут полуформальные тесты, но их нужно писать.
Логика будет такая же, как и для тестирования SendBotMessageService,
поэтому вынесим общую логику тестов в AbstractCommandTest класс,
и уже каждый конкретный тест-класс будет наследоваться и определять необходимые ему поля.

Отлично видно, что игра стоила свеч, и благодаря AbstractCommandTest мы получили в итоге простые и понятные тесты,
которые легко писать, легко понимать.
В довесок избавились от лишнего дублирования кода (привет принципу DRY -> Don’t Repeat Yourself).

3. Dockerfile

FROM adoptopenjdk/openjdk11:ubi
RUN mkdir /opt/app
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]

Первая строка — на основе чего будет состоять образ — adoptopenjdk/openjdk11;
Вторая строчка — добавляем аргумент в образ с именем JAR_FILE, который находится в папке target.
                 Причем нынешняя папка определяется по месту Dockerfile;
Третья строка — копируем в докер-образ jar нашего проекта;
Четвертая строка - по сути содержит массив, созданный из команды в терминале, которую разделили по пробелу.
                   То есть, в итоге будет выполнено следующее: “java -jar /app.jar”

Поэтому у нас вырисовывается нехилая схема:

    1. Запускаем баш скрипт.
    2. Баш скрипт запускает docker-compose.
    3. Docker-compose запускает docker контейнер с нашим приложением.
    4. Docker контейнер запускает наше приложение.

И вот нужно сделать так, чтобы две переменные — имя бота и его токен — прошли из 1 пункта в 4.
Причем так, чтобы эти две переменные использовались при запуске нашего java-приложения.

Пойдем с конца в начало. Мы уже знаем, какую команду нужно выполнить, чтобы запустить джарник.
Поэтому будем настраивать Dockerfile, чтобы он научился принимать две переменные и передавать их в запрос.

4. Docker-compose

version: '3.1'

services:
  tb:
    build:
      context: .
    environment:
      - BOT_NAME=${BOT_NAME}
      - BOT_TOKEN=${BOT_TOKEN}
    restart: always

Первая строка — это версия docker-compose.

services: говорит о том, что все следующие строки после этого (будут сдвинуты) — относятся к сервисам,
          которые мы настраиваем. У нас такой пока только один — java-приложение под названием tb.
          И уже под ним будут все его настройки.
          Например, build: context: . говорит о том, что мы будем искать Dockerfile в той же директории,
          что и docker-compose.yml.

А вот секция environment: будет отвечать за то, чтобы мы передали в Dockerfile необходимые переменные среды
(environment variables). Как раз то, что нам и нужно. Поэтому ниже мы переменные и передаем.
Их docker-compose будет искать в переменных операционной среды сервера. Добавим их в баш скрипте.

5. start.sh (Баш-скрипт)

#!/bin/bash

# Pull new changes
git pull

# Prepare Jar
mvn clean
mvn package

# Ensure, that docker-compose stopped
docker-compose stop

# Add environment variables
export BOT_NAME=$1
export BOT_TOKEN=$2

# Start new deployment
docker-compose up --build -d

Первая строка нужна для всех баш скриптов: без нее работать не будет.
А далее — просто набор команд в терминале, которые нужно выполнить.

К каждой команде подставлены комментарии, поэтому должно быть понятно.
Единственное, что хочется объяснить — это то, что значит $1 и $2. Это две переменные,
которые будут переданы в запуске баш скрипта.
При помощи команды export они будут добавлены в переменные сервера и считаны уже в docker-compose.
Это работает для убунты, для виндоуса, наверно, нет, но я не уверен.

6. stop.sh

#!/bin/bash

# Ensure, that docker-compose stopped
docker-compose stop

# Ensure, that the old application won't be deployed again.
mvn clean

Здесь мы останавливаем docker-compose и зачищаем джарник проекта, который лежит еще с прошлой сборки.
Делаем мы это для того, чтобы наш проект точно пересобирался.